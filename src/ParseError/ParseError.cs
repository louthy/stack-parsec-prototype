using LanguageExt.Traits;
using static LanguageExt.Prelude;

namespace LanguageExt.RefParsec;

/// <summary>
/// `ParseError` represents a parse error parametrised over the
/// stream type `S` and the custom data `E`.
/// 
/// `Semigroup` and `Monoid` instances of the data type allow us to merge
/// parse errors from different branches of parsing. When merging two
/// 'ParseError's, the longest match is preferred; if positions are the same,
/// custom data sets and collections of message items are combined. Note that
/// fancy errors take precedence over trivial errors in merging.
/// </summary>
/// <typeparam name="T">Token type</typeparam> 
/// <typeparam name="E">Error type</typeparam> 
public abstract record ParseError<E, T>(SourcePos Position) : Semigroup<ParseError<E, T>>
{
    /// <summary>
    /// Trivial errors, generated by the Megaparsec's machinery. The data
    /// constructor includes the offset of error, unexpected token (if any),
    /// and expected tokens.
    /// </summary>
    public record Trivial(SourcePos Position, Option<ErrorItem<T>> Unexpected, Set<ErrorItem<T>> Expected)
        : ParseError<E, T>(Position)
    {
        public override Func<State<T>, K<M, B>> WithHints<S, M, B>(
            Hints<T> hs, 
            Func<ParseError<E, T>, State<T>, K<M, B>> f) => 
            curry(f)(ParseError.Trivial<E, T>(Position, Unexpected, Expected + hs.Errors));
        
        static Func<ParseError<E, T>, Func<State<T>, K<M, B>>> curry<M, B>(Func<ParseError<E, T>, State<T>, K<M, B>> f) => 
            p => s => f(p, s);

        public override string ToString() =>
            (Unexpected.Case, Expected) switch
                              {
                                  (ErrorItem<T> un, { IsEmpty: true }) =>
                                      $"{Position} unexpected {un}",

                                  (ErrorItem<T> un, var ex) =>
                                      $"{Position} unexpected {un}, expected {string.Join(", ", ex)}",
                                  
                                  (null, { IsEmpty: true } ) =>
                                      $"{Position} parsing failed",
                                  
                                  (null, var ex) =>
                                      $"{Position} expected {string.Join(", ", ex)}",

                                  _ => throw new Exception("Impossible case")
                              };
    }

    /// <summary>
    /// Fancy, custom errors.
    /// </summary>
    public record Fancy(SourcePos Position, Set<ErrorFancy<E>> Errors)
        : ParseError<E, T>(Position)
    {
        public override Func<State<T>, K<M, B>> WithHints<S, M, B>(
            Hints<T> hs,
            Func<ParseError<E, T>, State<T>, K<M, B>> f) =>
            curry(f)(this);

        static Func<ParseError<E, T>, Func<State<T>, K<M, B>>> curry<M, B>(Func<ParseError<E, T>, State<T>, K<M, B>> f) => 
            p => s => f(p, s);
        
        public override string ToString() =>
            $"{Position} {string.Join("; ", Errors.Map(e => e.ToString()))}";
    }

    public abstract Func<State<T>, K<M, B>> WithHints<S, M, B>(
        Hints<T> hs, 
        Func<ParseError<E, T>, State<T>, K<M, B>> f);

    public ParseError<E, T> Combine(ParseError<E, T> rhs) => 
        ParseError.mergeError(this, rhs);
}
